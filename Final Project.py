# -*- coding: utf-8 -*-
"""Copy of sxuCopy of lab2_lambdas_MAKE_A_COPY.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TYAu-t7tq1ZzXsIBBJxZErHVAStM3QcJ
"""

import requests
import json
clientid = "K8PeHLf1A6dMAyhA8Zm27g"
#reques api data and store it into cache
def api_fetch(offs):
    mykey = "TZR3-NA_M36tECQaIge2qZTDJH8KwJCWZWd8nbG8PDY4w51TWn8Afm3_MUdkBpQilTrA1CvN72EJi0dDck1OJ9IJtJGGpa1tJPEieoPQ4HgeLiQBVkGb6UVYHixJYnYx"
    Endpoint = "https://api.yelp.com/v3/businesses/search"
    headers = {'Authorization': 'bearer %s' % mykey}
    #param = {"term": Term, "limit" : Limitn, "radius": 5000, "location": "Ann Arbor"}
    #param = { "limit" : Limitn, "radius": 5000, "location": "Michigan"}
    param = { "limit" : int(50), "offset" : offs, "radius": 5000, "location": "MI"}
    response = requests.get(url = Endpoint,  params = param, headers = headers)
    resultd = json.loads(response.text)
    resultd = resultd["businesses"]
    return resultd

def review_fetch(id):
    mykey = "TZR3-NA_M36tECQaIge2qZTDJH8KwJCWZWd8nbG8PDY4w51TWn8Afm3_MUdkBpQilTrA1CvN72EJi0dDck1OJ9IJtJGGpa1tJPEieoPQ4HgeLiQBVkGb6UVYHixJYnYx"
    Endpoint = f"https://api.yelp.com/v3/businesses/{id}/reviews"
    headers = {'Authorization': 'bearer %s' % mykey}
    response = requests.get(url = Endpoint,  headers = headers)
    resultd = json.loads(response.text)
    return resultd
def getbigdata(offs):
    data = []
    for i in range(offs):
        api_fetch(i)
        data += api_fetch(i)
    return data

CACHE_FILENAME = "cache.json"

def open_cache():
    try:
        cache_file = open(CACHE_FILENAME, 'r')
        cache_contents = cache_file.read()
        cache_dict = json.loads(cache_contents)
        cache_file.close()
    except:
        cache_dict = {}
    return cache_dict

def save_cache(cache_dict):
    dumped_json_cache = json.dumps(cache_dict)
    fw = open(CACHE_FILENAME,"w")
    fw.write(dumped_json_cache)
    fw.close() 

def Yelp_cache(n):
    n_key = str(n)
    if n_key in yelp_cache.keys():
        #print("8")
        return yelp_cache[n_key]
    else:
        k = getbigdata(n)
        yelp_cache[n_key] = k
        save_cache(yelp_cache)
        return yelp_cache[n_key]


yelp_cache = open_cache()

#create treenode and bst
class TreeNode:
    def __init__(self,Yname,val,left=None,right=None,
                                       parent=None):
        self.Yname = Yname
        self.payload =  []
        self.payload.append(val)
        self.leftChild = left
        self.rightChild = right
        self.parent = parent
    def hasLeftChild(self):
        return self.leftChild

    def hasRightChild(self):
        return self.rightChild

    def isLeftChild(self):
        return self.parent and self.parent.leftChild == self

    def isRightChild(self):
        return self.parent and self.parent.rightChild == self

    def isRoot(self):
        return not self.parent

    def isLeaf(self):
        return not (self.rightChild or self.leftChild)

    def hasAnyChildren(self):
        return self.rightChild or self.leftChild

    def hasBothChildren(self):
        return self.rightChild and self.leftChild

    def replaceNodeData(self,Yname,value,lc,rc):
        self.Yname = Yname
        self.payload = value
        self.leftChild = lc
        self.rightChild = rc
        if self.hasLeftChild():
            self.leftChild.parent = self
        if self.hasRightChild():
            self.rightChild.parent = self
class BinarySearchTree:   
    def __init__(self):
        self.root = None
        self.size = 0

    def length(self):
        return self.size

    def __len__(self):
        return self.size

    def __iter__(self):
        return self.root.__iter__()

    def put(self,Yname,val):
      if self.root:
        self._put(Yname,val, self.root)
        
      else: 
        self.root = TreeNode(Yname,val)
        #print(Yname)
      self.size = self.size + 1
    
    def _put(self,Yname,val,currentNode):
      if Yname == currentNode.Yname:
          (currentNode.payload).append(val)

      elif Yname < currentNode.Yname:
        if currentNode.hasLeftChild():
          self._put(Yname,val,currentNode.leftChild)
        else:
          currentNode.leftChild = TreeNode(Yname,val,parent=currentNode)
          #print(Yname)
      else:
        if currentNode.hasRightChild():
          self._put(Yname,val,currentNode.rightChild)
        else:
          currentNode.rightChild = TreeNode(Yname,val,parent=currentNode)
        #print(Yname)

    def get(self,Yname):
      if self.root:
        #print(self.root.Yname)
        res = self._get(Yname,self.root)
        if res:
          return res.payload
        else:
          return None
      else:
        return None
#I edit the get function, so if one category of the restaurant match it will return the restaurant
    def _get(self,Yname,currentNode):    
        if not currentNode:
            return None
        elif currentNode.Yname== Yname:
            return currentNode
        
        elif Yname < currentNode.Yname:
            return self._get(Yname,currentNode.leftChild)
        else:
            return self._get(Yname,currentNode.rightChild)        
  
   #seaborn
   # seaborn
#matplotlib     
        
    def __getitem__(self,Yname):
        return self.get(Yname)  


#it is where i put api data into bst
def createtree(tree, data):
    for i in data:
        k = []
        try:
            k.append(i["location"]["city"])
            k.append(i["price"])
            #k.append(i["rating"])
            k.append(i["categories"][0]["alias"])           
            tree.put(k, i) 
        except KeyError:
            a = k
    return tree
def catname(data):
    n = ['newamerican']
    for i in data:
        n.append(i["categories"][0]["alias"])   
    return n

cn = catname(Yelp_cache(int(1)))

datatree = BinarySearchTree()
#print(Yelp_cache(int(20)))
ok = createtree(datatree, Yelp_cache(int(2)))
#print(ok.get(['Detroit', '$$', 'ramen']))
#print(ok.length())
#print(ok.root.Yname)
#print((ok.root.hasLeftChild()).hasLeftChild().payload)

from tabulate import tabulate


def recommand (data):
    if data is None:
        return None 
    else:
        p = []
        u = []
        for i in range(len(data)):
            k = data[i]
            p.append(float(k["rating"]))
            u.append(k["name"])
        o = sorted(zip(p,u ), reverse=True)[:3]        
        return o

def rname(data):
    if data is None:
        return None
    else:
        n = len(data)
        print(f'we have {n} restaurants to recommend!')
        for i in data:
            
            print(i[1])
            


def prtable(a,data):
    table = []
    table.append(["Name","Rating","Location", "phone"])
    for i in a:
        l = []
        record = checkd(i[1], data)
        location = record["location"]['display_address']
        phone = record['display_phone']
        l.append(i[1])
        l.append(i[0])
        l.append(location)
        l.append(phone)
        table.append(l)

    return table

def checkd (inp, data):
    for i in data:
        if i["name"] == inp:
            return i

from bs4 import BeautifulSoup

def listd(all_review):
    for i in all_review:
        all_list= i.find_all('li')
        return all_list
def parad(li):
    s = []
    m = []
    for i in li:
        o = i.find_all("p")
        for p in o:
            if o is not None and o != []:
                k = p.find_all("span")
                s += k
    #print(s)
    for u in s:
        if u is not None and u != "<br/>":
         '''print(u)
            print("xxxxxxx")
            u.strip('<span class="raw__09f24__T4Ezm" lang="en">')
            u.strip('</span>')'''
        m += u
    #print(m)
    return m

def scraptdata(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    all_review = soup.find_all(attrs = {'aria-label':"Recommended Reviews"})
    data = listd(all_review)
    para = parad(data)
    #results = textr(para)
    return para

#store reviews in cache
CACHE_FILENAME = "review_cache.json"

def open_review_cache():
    try:
        cache_file = open(CACHE_FILENAME, 'r')
        cache_contents = cache_file.read()
        cache_dict = json.loads(cache_contents)
        cache_file.close()
    except:
        cache_dict = {}
    return cache_dict

def save_review_cache(cache_dict):
    dumped_json_cache = json.dumps(cache_dict)
    fw = open(CACHE_FILENAME,"w")
    fw.write(dumped_json_cache)
    fw.close() 

def R_cache(n):
    n_key = str(n)
    if n_key in r_cache.keys():
        #print("8")
        return r_cache[n_key]
    else:
        k = str(scraptdata(n))
        r_cache[n_key] = k
        save_review_cache(r_cache)
        return r_cache[n_key]


r_cache = open_review_cache()

from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt
def wc (word):
  word = splitw(word)
  comment_words = ''
  for i in word:
    # Converts each token into lowercase
      i = i.lower
  comment_words += " ".join(word)+" "

  stopwords = set(STOPWORDS)
  wordcloud = WordCloud(width = 800, height = 800,
                background_color ='white',
                stopwords = stopwords,
                min_font_size = 10).generate(comment_words)
  plt.figure(figsize = (8, 8), facecolor = None)
  plt.imshow(wordcloud)
  plt.axis("off")
  plt.tight_layout(pad = 0)
  plt.show()
  

  
# plot the WordCloud image

import re
def splitw (word):
  word = word.split()
  so = []
  for i in word:
    k = re.sub(",", "", i)
    q = re.sub("'", "", k)
    j = re.sub("<br/>", "", q)
    p = re.split("\s", j)
   
    so += p
  return so

import time
def Main(datatree):
    print("Welcome!")
    print("enter a city in Michigan that you want to search(capitalized with first letter)")
    a = input()
    print("enter your budget for dinner($,$$,$$$)")
    b = input()
    print("enter a category of food")
    print("here is a sample list of food category that you can choose")
    print(cn)
    c = input()
    keys = []
    keys.append(a)
    keys.append(b)
    keys.append(c)
    print(keys)
    res = datatree.get(keys)
    #res = datatree.get(['Detroit', '$$', 'ramen'])
    #print(res)
    
    #print(res)
    k = recommand(res)
    rname(k)
    #print(k)
    tb = prtable(k,res)
    print(tabulate(tb))
    r = "y"
    while True:
      print("enter the restaurant name that you want to know more about? enter'exit'to quit")
      time.sleep(3)
      r= input()
      if r == "exit":
        break
      record = checkd (r, res)
      urlkey = record["url"]
      word = R_cache(urlkey)
      rep = wc(word)
      print("do you want to know more about other restaurant?(y/n)")
      #rep = input("??")
    
Main(ok)